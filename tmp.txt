Return True if the object argument appears callable, False if not.
If this returns True, it is still possible that a
call fails, but if it is False, calling object will never succeed.
Note that classes are callable (calling a class returns
a new instance); instances are callable if their class has a __call__() method.
New in version 3.2: This function was first removed in Python 3.0 and then brought back in Python 3.2.
chr(i)
Return the string representing a character whose Unicode code point is the integer i.
For example, chr(97)
returns the string 'a', while chr(8364) returns the string '€'.
This is the inverse of ord().
The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in base 16).
ValueError will be
raised if i is outside that range.
A class method receives the class as an implicit first argument, just like an instance method receives the instance.
To declare a class method, use this idiom:
class C:
@classmethod
def f(cls, arg1, arg2): ...
The @classmethod form is a function decorator – see function for details.
A class method can be called either on the class (such as C.f()) or on an instance (such as C().f()).
The
instance is ignored except for its class.
If a class method is called for a derived class, the derived class object is
passed as the implied first argument.
Class methods are different than C++ or Java static methods.
If you want those, see staticmethod() in this
section.
For more information on class methods, see types.
Class methods can now wrap other descriptors such as property().
Changed in version 3.10:
Class methods now inherit the method attributes (__module__, __name__,
__qualname__, __doc__ and __annotations__) and have a new __wrapped__ attribute.
Changed in version 3.11: Class methods can no longer wrap other descriptors such as property().
Compile the source into a code or AST object.
Code objects can be executed by exec() or eval().
Refer to the ast module documentation for information
on how to work with AST objects.
The filename argument should give the file from which the code was read; pass some recognizable value if it wasn’t
read from a file ('<string>' is commonly used).
The mode argument specifies what kind of code must be compiled; it can be 'exec' if source consists of a
sequence of statements, 'eval' if it consists of a single expression, or 'single' if it consists of a single
8
Chapter 2.
Built-in Functions
The Python Library Reference, Release 3.12.0
interactive statement (in the latter case, expression statements that evaluate to something other than None will be
printed).
The optional arguments flags and dont_inherit control which compiler options should be activated and which future
features should be allowed.
If neither is present (or both are zero) the code is compiled with the same flags that
affect the code that is calling compile().
If the flags argument is given and dont_inherit is not (or is zero) then
the compiler options and the future statements specified by the flags argument are used in addition to those that
would be used anyway.
If dont_inherit is a non-zero integer then the flags argument is it – the flags (future features
and compiler options) in the surrounding code are ignored.
Compiler options and future statements are specified by bits which can be bitwise ORed together to specify multiple
options.
Compiler flags can be found in ast module, with PyCF_
prefix.
The argument optimize specifies the optimization level of the compiler; the default value of -1 selects the opti-
mization level of the interpreter as given by -O options.
Explicit levels are 0 (no optimization; __debug__ is
true), 1 (asserts are removed, __debug__ is false) or 2 (docstrings are removed too).
This function raises SyntaxError if the compiled source is invalid, and ValueError if the source contains
null bytes.
If you want to parse Python code into its AST representation, see ast.parse().
Raises an auditing event compile with arguments source and filename.
This event may also be raised by
implicit compilation.
Note: When compiling a string with multi-line code in 'single' or 'eval' mode, input must be terminated
by at least one newline character.
This is to facilitate detection of incomplete and complete statements in the code
module.
Warning: It is possible to crash the Python interpreter with a sufficiently large/complex string when compiling
to an AST object due to stack depth limitations in Python’s AST compiler.
Changed in version 3.2: Allowed use of Windows and Mac newlines.
Also, input in 'exec' mode does not have
to end in a newline anymore.
Added the optimize parameter.
Changed in version 3.5: Previously, TypeError was raised when null bytes were encountered in source.
New in version 3.8: ast.
PyCF_ALLOW_TOP_LEVEL_AWAIT can now be passed in flags to enable support for
top-level await, async for, and async with.
If
the first parameter is a string, it will be interpreted as a complex number and the function must be called without a
second parameter.
The second parameter can never be a string.
Each argument may be any numeric type (including
complex).
If imag is omitted, it defaults to zero and the constructor serves as a numeric conversion like int and
float.
If both arguments are omitted, returns 0j.
For a general Python object x, complex(x) delegates to x.__complex__().
If __complex__()
is not defined then it falls back to __float__().
If __float__() is not defined then it falls back to
__index__().
For example, complex('1+2j') is fine, but complex('1 + 2j') raises ValueError.
The complex type is described in Numeric Types — int, float, complex.
Grouping digits with underscores as in code literals is allowed.
Falls back to __index__() if __complex__() and __float__() are not defined.
This is a relative of setattr().
The arguments are an object and a string.
The string must be the name of
one of the object’s attributes.
The function deletes the named attribute, provided the object allows it.
For exam-
ple, delattr(x, 'foobar') is equivalent to del x.foobar.
The dict object is the dictionary class.
See dict and Mapping Types — dict for
documentation about this class.
For other containers see the built-in list, set, and tuple classes, as well as the collections module.
Without arguments, return the list of names in the current local scope.
With an argument, attempt to return a list
of valid attributes for that object.
If the object has a method named __dir__(), this method will be called and must return the list of attributes.
If the object does not provide __dir__(), the function tries its best to gather information from the object’s
__dict__ attribute, if defined, and from its type object.
If the object is a module object, the list contains the names of the module’s attributes.
If the object is a type or class object, the list contains the names of its attributes, and recursively of the
attributes of its bases.
Otherwise, the list contains the object’s attributes’ names, the names of its class’s attributes, and recursively
of the attributes of its class’s base classes.
The resulting list is sorted alphabetically.
For example:
# show the names in the module namespace
['__builtins__', '__name__', 'struct']
# show the names in the struct module
['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__',
'__initializing__', '__loader__', '__name__', '__package__',
'_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
'unpack', 'unpack_from']
(continues on next page)
10
Chapter 2.
Built-in Functions
The Python Library Reference, Release 3.12.0
(continued from previous page)
...
def __dir__(self):
...
return ['area', 'perimeter', 'location']
...
For example, metaclass attributes are not in the result list when the
argument is a class.
With mixed operand types, the rules for binary arithmetic operators apply.
For integers, the result is the same as (a // b, a % b).
